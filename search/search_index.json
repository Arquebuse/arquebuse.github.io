{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Arquebuse is an open-source notification system tailored specifically for enterprise environments, providing secure and efficient delivery of targeted notifications to Windows desktop users.</p> <p>Designed with simplicity at its core, Arquebuse integrates seamlessly with existing infrastructure, allowing administrators to easily select recipients, send critical application outage alerts, and request user acknowledgments directly via the native Windows notification center. </p> <p>It respects users' \"Do Not Disturb\" settings, ensuring alerts are delivered respectfully without disruption. Arquebuse simplifies enterprise communication, empowering organizations to effectively manage notifications at scale.</p>"},{"location":"#modules","title":"Modules","text":"<p>Arquebuse is composed of loosely coupled modules:</p> <ul> <li>Desktop\u2011App - A Windows service that registers with WNS, receives and displays notifications.</li> <li>Controller\u2011Core - A .NET\u00a08 Minimal API managing client registrations, AD queries, and sending WNS notifications (uses SQLite).</li> <li>Controller\u2011CLI - A PowerShell module to manage subscriptions and send notifications via Controller\u2011Core.</li> </ul>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Deliver targeted Windows notifications at scale.</li> <li>Integrate with Active Directory for precise targeting.</li> <li>Maintain simplicity, security, and enterprise readiness.</li> </ul>"},{"location":"#technologies","title":"Technologies","text":"<ul> <li>Desktop\u2011App: .NET\u00a08 Windows Service, WNS integration, JSON logging</li> <li>Controller\u2011Core: .NET\u00a08 Minimal API, Kestrel (HTTPS), System.DirectoryServices (LDAP), SQLite</li> <li>Controller\u2011CLI: PowerShell\u00a07+ module, REST API over HTTPS</li> </ul>"},{"location":"#project-status","title":"Project status","text":"<p>We are in the early stage of the project. Nothing is ready to use, but stay tuned, we move fast.</p>"},{"location":"#vibe-coding","title":"Vibe coding","text":"<p>This project and its documentation were created and maintained using AI tools like ChatGPT and GitHub Copilot. Feel free to mock the code logic, style, or anything else, no one will take offense \ud83d\ude09</p>"},{"location":"blueprints/controller-core/","title":"Controller-Core","text":""},{"location":"blueprints/controller-core/#1-high-level-architecture-overview","title":"1. High-Level Architecture Overview","text":""},{"location":"blueprints/controller-core/#client-registration","title":"Client Registration","text":"<ul> <li>The Desktop-App (Windows service) auto-registers with Windows Push Notification Service (WNS) to obtain a unique channel URI.</li> <li>On startup (and periodically, since channel URIs expire after ~30 days), the client requests a new WNS channel, then calls the Controller-Core <code>POST /register</code> endpoint over HTTPS, sending its channel URI and identity (e.g. AD username or device ID).</li> <li>The Controller-Core authenticates via an LDAP bind to Active Directory, stores the subscription (user/device + channel URI) in a SQLite database, and uses a read-only AD service account for least-privilege queries.</li> </ul>"},{"location":"blueprints/controller-core/#notification-dispatch-cli-trigger","title":"Notification Dispatch (CLI Trigger)","text":"<ul> <li>An administrator runs the Controller-CLI PowerShell module (e.g. <code>Send-Notification -Filter @{Group='IT'} -Message '\u2026'</code>), which invokes <code>POST /notify</code> on the Controller-Core, including filter criteria (AD group, specific user, or computer names).</li> <li>The Controller-Core authenticates the caller via LDAP, queries AD to expand filters into target user/computer names, looks up their channel URIs in the SQLite store, and proceeds to delivery.</li> </ul>"},{"location":"blueprints/controller-core/#wns-push-delivery","title":"WNS Push Delivery","text":"<ul> <li>The Controller-Core obtains an OAuth2 access token from WNS using the app\u2019s Package SID and secret (one global app identity).</li> <li>For each target channel URI, it issues an HTTPS <code>POST</code> with the toast payload and required headers to the WNS endpoint.</li> <li>WNS routes the notification to the appropriate device. The Desktop-App receives the push and displays it as a native Windows toast, logging the event locally in JSON.</li> </ul>"},{"location":"blueprints/controller-core/#unregistration-cleanup","title":"Unregistration &amp; Cleanup","text":"<ul> <li>The Desktop-App calls <code>DELETE /unregister</code> (e.g. on shutdown) to remove its subscription; the Controller-Core deletes the record.</li> <li>If WNS returns \u201c410 Gone\u201d for a channel, the Controller-Core purges that subscription.</li> <li>All significant events (registrations, notifications, delivery results, errors) are appended as JSON lines in a server audit log.</li> </ul>"},{"location":"blueprints/controller-core/#2-net-8-minimal-api-project-structure","title":"2. .NET 8 Minimal API Project Structure","text":"<ul> <li> <p>Controllers/   Minimal API endpoint handlers (e.g. <code>RegistrationController</code>, <code>NotificationController</code>) defining <code>/register</code>, <code>/unregister</code>, and <code>/notify</code>.</p> </li> <li> <p>Services/   Business logic and integrations:</p> </li> <li><code>LdapAuthService.cs</code> (LDAP auth &amp; queries)  </li> <li><code>AdQueryService.cs</code> (AD group/user resolution)  </li> <li> <p><code>WnsClient.cs</code> (WNS token acquisition &amp; push sending)</p> </li> <li> <p>Data/   Persistence layer:</p> </li> <li><code>SubscriptionDbContext.cs</code> (EF Core context for SQLite)  </li> <li><code>Subscription.cs</code> (model class)  </li> <li> <p><code>Migrations/</code> (EF Core migrations)</p> </li> <li> <p>Logging/   Configuration and helpers for structured JSON logs (e.g. Serilog).</p> </li> <li> <p>Database/   Contains SQLite file (<code>subscriptions.db</code>) or initialization scripts.</p> </li> <li> <p>Program.cs   Entry point configuring <code>WebApplication</code>, Kestrel HTTPS, DI for services and DbContext, endpoint mappings, and security middleware.</p> </li> <li> <p>appsettings.json   Holds configuration for LDAP, database, WNS credentials, and Kestrel.</p> </li> <li> <p>Dockerfile   Builds and publishes the .NET 8 service on a Windows Server Core image, exposes port 5001.</p> </li> <li> <p>docker-compose.yml   Defines the service for local development, mounts volumes for SQLite and certificates, and sets environment variables for secrets.</p> </li> </ul>"},{"location":"blueprints/controller-core/#3-key-classes-functions-pseudo-code-sketches","title":"3. Key Classes &amp; Functions (Pseudo-code Sketches)","text":""},{"location":"blueprints/controller-core/#ldapauthservice","title":"LdapAuthService","text":"<pre><code>public bool Authenticate(string username, string password) {\n    using var entry = new DirectoryEntry(\"LDAP://ldap.example.com/DC=example,DC=com\",\n                                         username, password) {\n        AuthenticationType = AuthenticationTypes.Secure\n    };\n    try {\n        _ = entry.NativeObject;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n\npublic List&lt;string&gt; QueryGroupMembers(string groupName) {\n    using var searcher = new DirectorySearcher {\n        Filter = $\"(&amp;(objectClass=user)(memberOf=CN={groupName},OU=Groups,DC=example,DC=com))\",\n        PropertiesToLoad = { \"sAMAccountName\" },\n        PageSize = 1000\n    };\n    var results = searcher.FindAll();\n    return results\n        .Cast&lt;SearchResult&gt;()\n        .Select(r =&gt; (string)r.Properties[\"sAMAccountName\"][0])\n        .ToList();\n}\n</code></pre>"},{"location":"blueprints/controller-core/#subscriptionrepository","title":"SubscriptionRepository","text":"<pre><code>public void AddSubscription(string userId, string channelUri) {\n    var sub = new Subscription {\n        UserOrDeviceId = userId,\n        ChannelUri      = channelUri,\n        RegisteredAt    = DateTime.UtcNow\n    };\n    _dbContext.Subscriptions.Add(sub);\n    _dbContext.SaveChanges();\n}\n\npublic void RemoveSubscription(string userId, string channelUri) {\n    var sub = _dbContext.Subscriptions\n                .FirstOrDefault(s =&gt; s.UserOrDeviceId == userId\n                                     &amp;&amp; s.ChannelUri == channelUri);\n    if (sub != null) {\n        _dbContext.Subscriptions.Remove(sub);\n        _dbContext.SaveChanges();\n    }\n}\n\npublic IEnumerable&lt;Subscription&gt; GetByUserIds(IEnumerable&lt;string&gt; userIds) {\n    return _dbContext.Subscriptions\n                     .Where(s =&gt; userIds.Contains(s.UserOrDeviceId))\n                     .ToList();\n}\n</code></pre>"},{"location":"blueprints/controller-core/#notificationcontroller","title":"NotificationController","text":"<pre><code>[HttpPost(\"/register\")]\npublic IActionResult Register([FromBody] ClientInfo info, HttpContext ctx) {\n    if (!_ldap.Authenticate(info.User, info.Password))\n        return Unauthorized();\n    _repo.AddSubscription(info.User, info.ChannelUri);\n    return Ok();\n}\n\n[HttpDelete(\"/unregister\")]\npublic IActionResult Unregister([FromBody] ClientInfo info) {\n    _repo.RemoveSubscription(info.User, info.ChannelUri);\n    return NoContent();\n}\n\n[HttpPost(\"/notify\")]\npublic async Task&lt;IActionResult&gt; Notify([FromBody] NotifyRequest req) {\n    if (!_ldap.Authenticate(req.Caller, req.Credential))\n        return Unauthorized();\n    var targets = _adQuery.QueryGroupMembers(req.Filters.Group);\n    var subs    = _repo.GetByUserIds(targets);\n    foreach (var sub in subs) {\n        await _wns.SendToastAsync(sub.ChannelUri, req.Message);\n    }\n    return Ok(new { Count = subs.Count() });\n}\n</code></pre>"},{"location":"blueprints/controller-core/#wnsclient","title":"WnsClient","text":"<pre><code>private string _cachedToken;\nprivate DateTime _tokenExpiry;\n\npublic async Task&lt;string&gt; AcquireAccessTokenAsync() {\n    if (DateTime.UtcNow &lt; _tokenExpiry)\n        return _cachedToken;\n\n    var form = new Dictionary&lt;string, string&gt; {\n        [\"grant_type\"]    = \"client_credentials\",\n        [\"client_id\"]     = _sid,\n        [\"client_secret\"] = _secret,\n        [\"scope\"]         = \"notify.windows.com\"\n    };\n    var res = await _http.PostAsync(\"https://login.live.com/accesstoken.srf\",\n                                    new FormUrlEncodedContent(form));\n    var json = await res.Content.ReadAsStringAsync();\n    var doc  = JsonDocument.Parse(json);\n    _cachedToken = doc.RootElement.GetProperty(\"access_token\").GetString();\n    _tokenExpiry = DateTime.UtcNow.AddMinutes(20);\n    return _cachedToken;\n}\n\npublic async Task SendToastAsync(string channelUri, string payloadXml) {\n    var token = await AcquireAccessTokenAsync();\n    using var req = new HttpRequestMessage(HttpMethod.Post, channelUri) {\n        Content = new StringContent(payloadXml, Encoding.UTF8, \"text/xml\")\n    };\n    req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n    req.Headers.Add(\"X-WNS-Type\", \"wns/toast\");\n\n    var res = await _http.SendAsync(req);\n    if (res.StatusCode == HttpStatusCode.Gone ||\n        res.StatusCode == HttpStatusCode.NotFound) {\n        _repo.RemoveSubscriptionForUri(channelUri);\n    }\n    // log success or error\n}\n</code></pre>"},{"location":"blueprints/controller-core/#4-sample-configuration-snippets","title":"4. Sample Configuration Snippets","text":""},{"location":"blueprints/controller-core/#appsettingsjson","title":"appsettings.json","text":"<pre><code>{\n  \"LDAP\": {\n    \"Server\":                 \"ldaps://ad.example.com:636\",\n    \"BaseDN\":                 \"DC=example,DC=com\",\n    \"ServiceAccount\":         \"CN=ArquebuseReader,OU=ServiceAccounts,DC=example,DC=com\",\n    \"ServiceAccountPassword\": \"P@ssw0rd!\"\n  },\n  \"ConnectionStrings\": {\n    \"Subscriptions\": \"Data Source=./Data/subscriptions.db\"\n  },\n  \"WNS\": {\n    \"PackageSID\": \"ms-app://&lt;YourAppSID&gt;\",\n    \"SecretKey\":  \"&lt;YourWNSSecretKey&gt;\"\n  },\n  \"Kestrel\": {\n    \"Endpoints\": {\n      \"Https\": {\n        \"Url\":         \"https://0.0.0.0:5001\",\n        \"Certificate\": {\n          \"Path\":     \"certs/ArquebuseDev.pfx\",\n          \"Password\": \"DevCertPassword\"\n        }\n      }\n    }\n  },\n  \"Logging\": {\n    \"LogLevel\": { \"Default\": \"Information\" }\n  }\n}\n</code></pre>"},{"location":"blueprints/controller-core/#dockerfile","title":"Dockerfile","text":"<pre><code># Build stage\nFROM mcr.microsoft.com/dotnet/sdk:8.0-windowsservercore-ltsc2022 AS build\nWORKDIR /src\nCOPY . .\nRUN dotnet restore\nRUN dotnet publish -c Release -o /app\n\n# Runtime stage\nFROM mcr.microsoft.com/dotnet/aspnet:8.0-windowsservercore-ltsc2022 AS final\nWORKDIR /app\nCOPY --from=build /app ./\nEXPOSE 5001\nENTRYPOINT [\"dotnet\", \"Arquebuse.ControllerCore.dll\"]\n</code></pre>"},{"location":"blueprints/controller-core/#docker-composeyml","title":"docker-compose.yml","text":"<pre><code>version: '3.8'\nservices:\n  controller-core:\n    build: .\n    image: arquebuse/controller-core:dev\n    ports:\n      - \"5001:5001\"\n    volumes:\n      - ./Data:/app/Data\n      - ./certs:/app/certs:ro\n    environment:\n      ASPNETCORE_ENVIRONMENT: \"Development\"\n      LDAP__ServiceAccountPassword: \"P@ssw0rd!\"\n      WNS__SecretKey:            \"&lt;YourWNSSecretKey&gt;\"\n      ASPNETCORE_Kestrel__Endpoints__Https__Url:              \"https://0.0.0.0:5001\"\n      ASPNETCORE_Kestrel__Endpoints__Https__Certificate__Path: \"/app/certs/ArquebuseDev.pfx\"\n      ASPNETCORE_Kestrel__Endpoints__Https__Certificate__Password: \"DevCertPassword\"\n</code></pre>"},{"location":"blueprints/controller-core/#6-best-practices","title":"6. Best Practices","text":"<ul> <li>HTTPS Hardening   Enforce HTTPS only, enable HSTS, restrict to TLS 1.2 or higher, and rotate certificates regularly.</li> <li>LDAP Querying   Use LDAPS or StartTLS; apply efficient filters; retrieve only required attributes; implement paging for large groups; and dispose of Directory objects promptly.</li> <li>WNS Credentials   Store Package SID and secret in a secure vault (environment variables, Key Vault, etc.); cache OAuth tokens to minimize token requests; and never log secrets.</li> <li>Logging &amp; Auditing   Emit structured JSON logs with timestamps, user IDs, message IDs, and delivery statuses\u2014avoid logging full channel URIs or tokens.</li> </ul>"},{"location":"blueprints/controller-core/#7-integration","title":"7. Integration","text":""},{"location":"blueprints/controller-core/#desktop-app-integration","title":"Desktop-App Integration","text":"<ul> <li>On startup, the Windows service obtains a WNS channel URI and calls <code>POST /register</code> with AD credentials.</li> <li>The app renews its channel periodically (before the ~30-day expiry) and updates the server.</li> <li>Incoming toasts are displayed via the Windows Notifications API; events are logged locally in JSON.</li> </ul>"},{"location":"blueprints/controller-core/#controller-cli-integration","title":"Controller-CLI Integration","text":"<ul> <li>A PowerShell module offers cmdlets (e.g. <code>Get-Subscribers</code>, <code>Send-Notification</code>) that wrap the Controller-Core REST API.</li> <li>Authentication uses AD credentials; the CLI handles JSON payloads and HTTP calls.</li> <li>Supports skipping certificate validation in dev, and can be scripted for automation scenarios.</li> </ul>"},{"location":"setup_guides/controller/","title":"Controller","text":""},{"location":"setup_guides/controller/#step-by-step-setup-instructions-development","title":"Step-by-Step Setup Instructions (Development)","text":"<ol> <li>Generate and Trust a Dev Certificate</li> </ol> <pre><code>dotnet dev-certs https -ep certs/ArquebuseDev.pfx -p \"DevCertPassword\" -t\n</code></pre> <ol> <li>Verify the Certificate Is Trusted</li> </ol> <ul> <li>On Windows: run <code>certmgr.msc</code> and look under Trusted Root Certification Authorities.  </li> <li>On macOS/Linux: import into your system keychain or trust store.</li> </ul> <ol> <li>Set Up a Mock LDAP Directory</li> </ol> <ul> <li>Option A: AD LDS on Windows \u2013 install AD LDS, create an instance, add OUs/users/groups.  </li> <li>Option B: OpenLDAP Container</li> </ul> <pre><code>docker run -p 389:389 \\\n   --name ldap \\\n   -e LDAP_DOMAIN=\"example.com\" \\\n   -e LDAP_ORGANISATION=\"Example Corp\" \\\n   -e LDAP_ADMIN_PASSWORD=\"adminpass\" \\\n   osixia/openldap:1.5.0\n</code></pre> <p>Then use Apache Directory Studio (or similar) to add entries.</p> <ol> <li>Database Migrations and Seeding</li> </ol> <pre><code>dotnet build\ndotnet ef database update\n</code></pre> <p>Optionally seed subscriptions via the API or directly via EF Core.</p> <ol> <li>Run the Controller-Core Service</li> </ol> <ul> <li>Direct:</li> </ul> <pre><code>dotnet run --project Arquebuse.ControllerCore\n</code></pre> <ul> <li>Docker Compose:</li> </ul> <pre><code>docker-compose up\n</code></pre> <ol> <li>Test Registration and Notification</li> </ol> <pre><code># Register\n$body = @{ user=\"jdoe\"; channelUri=\"https://wns.notify.windows.com/?token=abcd\" }\n$cred = Get-Credential -Message \"AD credentials\"\nInvoke-RestMethod -Uri https://localhost:5001/register `\n                  -Method POST `\n                  -Body ($body | ConvertTo-Json) `\n                  -ContentType \"application/json\" `\n                  -Credential $cred\n# Notify\n$notif = @{ filters=@{ User=\"jdoe\" }; message=\"Test alert via CLI\" }\nInvoke-RestMethod -Uri https://localhost:5001/notify `\n                  -Method POST `\n                  -Body ($notif | ConvertTo-Json) `\n                  -ContentType \"application/json\" `\n                  -Credential $cred\n</code></pre> <ol> <li>Trusting Certificates for CLI/Clients</li> </ol> <ul> <li>Dev-only workaround (PowerShell):</li> </ul> <pre><code>[System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }\n</code></pre> <ul> <li>Recommended: install the dev certificate into the OS trust store so normal validation passes.</li> </ul>"}]}